---
layout    : wiki
title     : 2022년 메모
summary   : 
date      : 2022-01-04 23:01:07 +0900
updated   : 2022-01-21 23:03:12 +0900
tag       : 
public    : true
published : true
parent    : [[memo]]
latex     : false
---
* TOC
{:toc}

## 2022-01-21
- caching 관련 redis 활용에 대한 글
	- <https://junshock5.tistory.com/105>
- local cache vs global cache
	- local cache
		- 서버마다 cache가 존재
		- 각 서버의 resource를 사용
		- 속도가 빠름
		- 데이터 변경 시 모든 서버의 cache에 변경 사항이 전달되어야 함
		- 읽기 전용 데이터에 적합
	- global cache
		- 여러 서버에서 하나의 cache 서버에 접근
		- 서버 간의 데이터 공유가 쉽다
		- 네트워크를 거치기 때문에 local cache보다 속도가 느림

## 2022-01-20
- 제한 횟수의 retry가 있는 Redis의 Optimistic lock 구현 방법
  - <https://github.com/eric-wu/dashboard/wiki/3.-Redis-Transactions-via-Spring-Data-Redis#optimistic-locking-using-watch-multi-and-exec>
- Redis sentinel은 잘 안 쓰고, 대부분 Redis cluster를 사용한다.
  - Redis sentinel의 경우 master가 하나이기 때문에, thread가 하나다. Redis cluster는 master가 여러 개이기 때문에 분산 저장이 가능하다.

## 2022-01-19
- Redis transaction은 rollback이 없다. 대신, EXEC 실행 전 DISCARD할 수 있다

## 2022-01-18
- Redis sentinel은 설정이 다르기 때문에 configuration 재 작성해야 함
	```java
	@Configuration
	@RequiredArgsConstructor
	public class RedisConfig {

		private final RedisProperties redisProperties;

		@Bean
			public RedisConnectionFactory redisConnectionFactory() {
				RedisSentinelConfiguration redisSentinelConfiguration = 
				  new RedisSentinelConfiguration()
					  .master("192.168.219.15")
					  .sentinel("192.168.219.16", 7000)
					  .sentinel("192.168.219.17", 7000);
				return new LettuceConnectionFactory(redisSentinelConfiguration);
			}

		@Bean
			public RedisTemplate<?, ?> redisTemplate() {
				RedisTemplate<?, ?> redisTemplate = new RedisTemplate<>();
				redisTemplate.setConnectionFactory(redisConnectionFactory());
				return redisTemplate;
			}
	}
```

## 2022-01-17
- redis check and set이 왜 하나의 transaction으로 안 되는지 잘 설명되어 있는 stackoverflow 답변
  - <https://stackoverflow.com/questions/10750626/transactions-and-watch-statement-in-redis>
- redis transaction의 watch, multi, exec에 대해 잘 설명되어 있는 글
  - <https://caileb.tistory.com/205>

## 2022-01-16
- <https://techblog.woowahan.com/2709/>
  - 재고는 변경이 가능하기 때문에, 남은 재고를 관리하는 것보다 `재고 사용량`을 관리하는 것이 좋다
    	- 남은 재고를 관리하게 되면 재고가 변경되었을 때, 추가적인 작업이 필요하기 때문이다
- 동시성 제어 관련 참고 링크
  - <https://velog.io/@p4rksh/RDB의-동시성과-일관성-이슈를-어떻게-처리할-것인가>
- Redis를 통한 동시성 제어 관련 참고 링크
  - <https://redis.com/ebook/part-2-core-concepts/chapter-4-keeping-data-safe-and-ensuring-performance/4-4-redis-transactions/4-4-3-purchasing-items/>

## 2022-01-15
- [[programmers-17683]]

## 2022-01-14
- @Transactional readOnly가 있다
- Service단이 단순 Repository의 Wrapping이라면 Controller에서 Repository를 바로 쓰는 것도 고려해볼 수 있다 

## 2022-01-13
- redis 메모리 측정
  - SET 자료구조에 SADD로 10개 데이터 추가 ⇒ 0.19KB 사용
  - 0.19KB(10개 데이터가 포함된 set 하나) x 유저 50,000,000명 x 정책 50개 = 475,000,000KB = 452.995GB
- 팀원과의 소소한 공유 내용
  - git commit 히스토리 보기
  ```sh
  git log  --all  --decorate --oneline --graph  # a dog
  ```  
  - global gitignore 적용
  ```sh
  git config --global core.excludesFile ~/.gitignore
  ```
	

## 2022-01-12
- <https://techblog.woowahan.com/2709/>에서 비동기를 적용해도 괜찮은 이유
  - 재고사용량 증가 방식을 동기 방식으로 처리함으로써, 절대 재고가 더 팔리는일은 발생하지 않는다.
    - 늦게 처리된다 하더라도 최악의 문제가 안 생긴다

## 2022-01-11
- spring boot 2.5.8 적용했는데, logback 1.2.9 버전으로 되어 있음
  - logback 1.2.9 버전은 취약점 해결한 버전인 것 같음([참고 링크](https://veneas.tistory.com/entry/Spring-Boot-%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8-Logback-%EC%B7%A8%EC%95%BD%EC%A0%90-%EC%A1%B0%EC%B9%98-CVE-2021-42550))

## 2022-01-10
- 일정 짜는데 시간이 많이 소요되었다. 내가 얼마나 시간을 잘 활용하는지에 대한 대략적인 감이 필요하다

## 2022-01-08
- [[programmers-17676]]

## 2022-01-07
- 백엔드는 비주얼적으로 보여주기 어렵지만, 성능 테스트 등으로 보여줄 수 있다
- history의 경우 변경은 하지 않는다. 말 그대로 history이기 때문에 실패하면 실패한대로, 성공하면 성공한대로 기록한다
- 하나의 데이터 타입으로 표현하지 못하는 경우 column을 여러 개 생성하는 것도 하나의 방법이 될 수 있다

## 2022-01-06
- 아키텍처 설계 시 sequence 다이어그램 그리는 것을 추천 받음
- 돈을 다루기 위해서는 소수점 정확도가 높은 BigDecimal을 사용하는 것이 좋다
- 공유 자원의 동시성 제어를 위한 비관적 lock

## 2022-01-05
- 동일한 과제 요구사항에 대해 서로의 이해가 많이 다를 수 있다는 것을 또 한 번 깨달을 수 있었음

## 2022-01-04
- 카프카
  - 재처리로 유명한 메시지 큐
  - offset만 알면 offset으로 접근 가능
  - 디스크에도 남음

