---
layout  : wiki
title   : 
summary : 
date    : 2019-03-11 18:51:43 +0900
updated : 2019-03-11 19:05:35 +0900
tags    : 
toc     : true
public  : true
parent  : 
latex   : false
---
* TOC
{:toc}

## 0. 개요

## 1. 코드

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
#include <deque>
#include <cstring>

using namespace std;

/*
면의 번호
0 : U, 1 : F
2 : L, 3 : R
4 : B, 5 : D
*/
char cube[6][3][3];
char schar[8] = "wrgboy";

// cube 데이터를 통해 4면을 이어붙인 2차원 배열
char board[3][12];

void init()
{
	for (int d = 0; d < 6; d++)
		for (int i = 0; i < 3; i++)
			for (int j = 0; j < 3; j++)
				cube[d][i][j] = schar[d];
}

// 90도 회전
void rotate90(char arr[3][3], bool isPositive)
{
	char temp[3][3];
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			if (isPositive)
				temp[j][2 - i] = arr[i][j];
			else
				temp[i][j] = arr[j][2 - i];
		}
	}
	memcpy(arr, temp, sizeof(temp));
}

// cube 데이터를 통해 4면 이어진 board 중 idx의 위치에 세팅하는 함수
// idx : 4면 중 어느 위치에 붙일지에 대한 index
// dir : 이어 붙일 면 번호
void importBoard(int idx, int dir, int rotateCnt)
{
	char tmp[3][3];
	memcpy(tmp, cube[dir], sizeof(tmp));

	for (int i = 0; i < rotateCnt; i++)
		rotate90(tmp, true);

	for (int i = 0; i < 3; i++)
		for (int j = 0; j < 3; j++)
			board[i][idx*3 + j] = tmp[i][j];
}

// 4면을 이어붙인 board로부터 해당 idx의 cube 데이터 가져오기
// idx : 4면 중 어느 위치에 붙일지에 대한 index
// dir : 가져올 면 번호
void exportBoard(int idx, int dir, int rotateCnt)
{
	char tmp[3][3];
	for (int i = 0; i < 3; i++)
		for (int j = 0; j < 3; j++)
			tmp[i][j] = board[i][j + idx*3];

	for (int i = 0; i < rotateCnt; i++)
		rotate90(tmp, true);

	for (int i = 0; i < 3; i++)
		for (int j = 0; j < 3; j++)
			cube[dir][i][j] = tmp[i][j];
}

// 연산을 수행하는 함수
int func(char direction, bool isPositive)
{
	memset(board, 0, sizeof(board));
	
	deque<char> deq;
	int dir[4]; 	// direction이 맨 윗면이라고 가정했을 때의 이어붙인 4면의 번호
	int rotate[4]; 	// direction 각각의 회전 각도 (각도 = value * 90도)
	int idx; 		// direction의 면 번호
	
	switch (direction)
	{
	case 'U':
	{
		int tmpdir[4] = { 2, 1, 3, 4 };
		int tmprot[4] = { 0, 0, 0, 0 };
		memcpy(dir, tmpdir, sizeof(dir));
		memcpy(rotate, tmprot, sizeof(rotate));
		idx = 0;
		break;
	}
	case 'D':
	{
		int tmpdir[4] = { 3, 1, 2, 4 };
		int tmprot[4] = { 2, 2, 2, 2 };
		memcpy(dir, tmpdir, sizeof(dir));
		memcpy(rotate, tmprot, sizeof(rotate));
		idx = 5;
		break;
	}
	case 'F':
	{
		int tmpdir[4] = { 2, 5, 3, 0 };
		int tmprot[4] = { 3, 2, 1, 2 };
		memcpy(dir, tmpdir, sizeof(dir));
		memcpy(rotate, tmprot, sizeof(rotate));
		idx = 1;
		break;

	}
	case 'B':
	{
		int tmpdir[4] = { 3, 5, 2, 0 };
		int tmprot[4] = { 3, 0, 1, 0 };
		memcpy(dir, tmpdir, sizeof(dir));
		memcpy(rotate, tmprot, sizeof(rotate));
		idx = 4;
		break;

	}
	case 'R':
	{
		int tmpdir[4] = { 1, 5, 4, 0 };
		int tmprot[4] = { 3, 1, 1, 3 };
		memcpy(dir, tmpdir, sizeof(dir));
		memcpy(rotate, tmprot, sizeof(rotate));
		idx = 3;
		break;
	}
	case 'L':
	{
		int tmpdir[4] = { 4, 5, 1, 0 };
		int tmprot[4] = { 3, 3, 1, 1 };
		memcpy(dir, tmpdir, sizeof(dir));
		memcpy(rotate, tmprot, sizeof(rotate));
		idx = 2;
		break;
	}
	default :
		break;
	}
	
	for (int i = 0; i < 4; i++)
		importBoard(i, dir[i], rotate[i]);

	for (int j = 0; j < 12; j++)
		deq.push_back(board[0][j]);
	if (isPositive)
	{
		for (int i = 0; i < 3; i++)
		{
			char item = deq.front();
			deq.pop_front();
			deq.push_back(item);
		}
	}
	else
	{
		for (int i = 0; i < 3; i++)
		{
			char item = deq.back();
			deq.pop_back();
			deq.push_front(item);
		}
	}
	for (int j = 0; j < 12; j++)
		board[0][j] = deq[j];

	rotate90(cube[idx], isPositive);

	for (int i = 0; i < 4; i++)
		exportBoard(i, dir[i], (4-rotate[i])%4);

	return 0;
}

int main()
{
	int testcase = 0;
	scanf("%d", &testcase);

	for (int tc = 1; tc <= testcase; tc++)
	{
		init();

		int N = 0;
		scanf("%d", &N);

		for (int i = 0; i < N; i++)
		{
			char input[3];
			scanf("%s", input);
			func(input[0], input[1] == '+' ? true : false);
		}

		for (int i = 0; i < 3; i++)
		{
			for (int j = 0; j < 3; j++)
				printf("%c", cube[0][i][j]);
			printf("\n");
		}
	}
}
```

